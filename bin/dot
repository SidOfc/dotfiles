#!/usr/bin/env ruby

require 'fileutils'

# Dotfiles
module Dotfiles
  IGNORE = /.*(?:\.\.?|README\.md|\.git|\.DS_Store|ssion\.vim|backup)$/
  SHELL  = ENV.fetch('SHELL', nil).freeze
  HOME   = Dir.home.freeze
  ROOT   = File.expand_path('../').freeze
  BACKUP = File.join(ROOT, 'backup').freeze
  ZCOMP  = File.join(ROOT, 'zsh').freeze

  def self.run!
    send(*ARGV)
  rescue
    exit 1
  end

  # rubocop:disable Style/StringLiterals
  # rubocop:disable Metrics/LineLength
  def self.help
    puts "USAGE:  dot COMMAND [ARGS]"
    puts ""
    puts "STATUS:"
    puts "    ROOT:        #{ROOT}"
    puts "    HOME:        #{HOME}"
    puts ""
    puts "    SHELL:       #{SHELL}"
    puts "    ZCOMPILE:    #{ZCOMP}"
    puts ""
    puts "    BACKUP:      #{ROOT}/backup"
    puts "    LAST BACKUP: #{last_backup}"
    puts ""
    puts "COMMAND        ARGS        DESC"
    puts ""
    puts "    backup                 create a copy of dotfiles and folders in {BACKUP} that would otherwise"
    puts "                           be overwritten by the command: dot ln!"
    puts "    last_backup            prints the path of the last backup in {BACKUP} or exit 1"
    puts "    unlink                 unlinks files matching {ROOT} filename in {HOME}"
    puts "    ln                     symlink {ROOT} to {HOME}"
    puts "    ln!                    same as ln, but use force"
    puts "    ls         [SRC]       list filename and symlink in {HOME} that matches a file in {ROOT}"
    puts "                           [SRC] can be one of 'root' or 'home'. When 'home' show matching"
    puts "                           matching dotfiles in {HOME}, when 'root' show dotfiles in {ROOT}"
  end
  # rubocop:enable

  def self.root
    @root ||= Dir.glob("#{ROOT}/{*,.*}").reject { |path| path.match IGNORE }
  end

  def self.home
    @home ||= Dir.glob("#{HOME}/{#{root.map(&File.method(:basename)).join(',')}}")
  end

  def self.last_backup
    Dir.glob(File.join(BACKUP, '*')).sort&.last || raise
  end

  def self.backup
    current_dir = File.join BACKUP, Time.now.to_i.to_s
    ml          = home.map(&:size).max

    Dir.mkdir BACKUP unless Dir.exists? BACKUP
    Dir.mkdir current_dir

    home.map do |original_dot|
      ::FileUtils.cp_r original_dot, current_dir
      "[cp] #{original_dot.ljust(ml)} => #{current_dir}"
    end
  end

  def self.zcompile
    Dir.glob(File.join(ZCOMP, '*.zwc')).map(&File.method(:unlink))
    targets = Dir.glob(File.join(ZCOMP, '*'))
    tml     = targets.map(&:size).max
    targets.map do |target|
      compiled = system "zsh -c 'zcompile -Uz #{target}'"
      "[#{compiled ? '++' : '--'}] #{target.ljust(tml)} => #{target}.zwc"
    end
  end

  def self.ls(path = nil)
    return send path if path && respond_to?(path)

    ml = home.map(&:size).max
    home.map { |hd| "#{hd.ljust(ml)} ~> #{File.realpath(hd)}" }
  end

  def self.ln!
    backup && unlink && ln
  end

  def self.ln
    maxlen = root.map(&:size).max

    root.map do |srcdot|
      dst = "#{HOME}/#{File.basename(srcdot)}"

      File.symlink srcdot, dst if (link = !File.exist?(dst))
      "[#{link ? '++' : '--'}] #{srcdot.ljust(maxlen)} ~> #{dst}"
    end
  end

  def self.unlink
    home.map(&File.method(:unlink))
  end
end

puts Dotfiles.run!
